{"tagline":"Dependency injection for node.js applications","body":"rewire adds a special setter and getter to modules so you can modify their behaviour for better unit testing. You may\r\n\r\n- introduce mocks for other modules\r\n- leak private variables\r\n- override variables within the module.\r\n\r\nrewire does **not** load the file and eval the contents to emulate node's require mechanism. In fact it uses node's own require to load the module. Thus your module behaves exactly the same in your test environment as under regular circumstances (except your modifications).\r\n\r\n**Debugging is fully supported.**\r\n\r\nFurthermore rewire comes also with support for [browserify](https://github.com/substack/node-browserify). You just\r\nhave to add rewire as a middleware (see below).\r\n\r\n[![Build Status](https://secure.travis-ci.org/jhnns/rewire.png?branch=master)](http://travis-ci.org/jhnns/rewire)\r\n\r\n<br />\r\n\r\nInstallation\r\n------------\r\n\r\n`npm install rewire`\r\n\r\n**For older node versions:**<br />\r\nrewire is tested with node 0.6.x - 0.8.x. I recommend to run the unit tests via `mocha` in the rewire-folder before\r\nusing rewire with other node versions.\r\n\r\n**Use with [browserify](https://github.com/substack/node-browserify):**<br />\r\n\r\n```javascript\r\nvar b = require(\"browserify\")({debug: true});\r\n\r\nb.use(require(\"rewire\").browserify);\r\n```\r\n\r\nAfter that rewire works exactly as in node.\r\n\r\n<br />\r\n\r\nExamples\r\n--------\r\n\r\n```javascript\r\nvar rewire = require(\"rewire\");\r\n\r\n\r\n// rewire acts exactly like require.\r\nvar myModule = rewire(\"../lib/myModule.js\");\r\n\r\n\r\n// Your module will now export a special setter and getter for private variables.\r\nmyModule.__set__(\"myPrivateVar\", 123);\r\nmyModule.__get__(\"myPrivateVar\"); // = 123\r\n\r\n\r\n// This allows you to mock almost everything within the module e.g. the fs-module.\r\n// Just pass the variable name as first parameter and your mock as second.\r\nmyModule.__set__(\"fs\", {\r\n    readFile: function (path, encoding, cb) {\r\n        cb(null, \"Success!\");\r\n    }\r\n});\r\nmyModule.readSomethingFromFileSystem(function (err, data) {\r\n    console.log(data); // = Success!\r\n});\r\n\r\n\r\n// All later requires will now return the module with the mock.\r\nmyModule === require(\"./myModule.js\"); // = true\r\n\r\n\r\n// You can set different variables with one call.\r\nmyModule.__set__({\r\n    fs: fsMock,\r\n    http: httpMock,\r\n    someOtherVar: \"hello\"\r\n});\r\n\r\n\r\n// You may also override globals. These changes are only within the module, so\r\n// you don't have to be concerned that other modules are influenced by your mock.\r\nmyModule.__set__({\r\n    console: {\r\n        log: function () { /* be quiet */ }\r\n    },\r\n    process: {\r\n        argv: [\"testArg1\", \"testArg2\"]\r\n    }\r\n});\r\n\r\n\r\n// But be careful, if you do something like this you'll change your global\r\n// console instance.\r\nmyModule.__set__(\"console.log\", function () { /* be quiet */ });\r\n\r\n\r\n// By getting private variables you can test for instance if your\r\n// module is in a specific state\r\nassert.ok(myModule.__get__(\"currentState\") === \"idle\");\r\n\r\n\r\n// You can also disable caching when loading the rewired module. All\r\n// subsequent calls of require() will than return the original module again.\r\nrewire(\"./myModule.js\") === require(\"./myModule.js\"); // = true\r\nrewire(\"./myModule.js\", false) === require(\"./myModule.js\"); // = false\r\n\r\n\r\n// Every call of rewire returns a new instance and overwrites the old\r\n// one in the module cache.\r\nrewire(\"./myModule.js\") === rewire(\"./myModule.js\"); // = false\r\n\r\n\r\n// If you want to remove all your rewired modules from\r\n// cache just call rewire.reset().\r\n// Do this after every single unit test to ensure a clean testing environment.\r\nrewire.reset();\r\n```\r\n\r\n<br />\r\n\r\n##API\r\n\r\n**rewire(***filename, cache***): {RewiredModule}**\r\n\r\n- *{!String} filename*: <br/>\r\nPath to the module that shall be rewired. Use it exactly like require().\r\n\r\n- *{Boolean=true} cache (optional)*: <br />\r\nIndicates whether the rewired module should be cached by node so subsequent calls of `require()` will\r\nreturn the rewired module. Further calls of `rewire()` will always overwrite the cache.\r\n\r\n**rewire.reset()**\r\n\r\nRemoves all rewired modules from `require.cache`. Every `require()` will now return the original module again.\r\n\r\n**RewiredModule.&#95;&#95;set&#95;&#95;(***name, value***)**\r\n\r\n- *{!String} name*: <br/>\r\nName of the variable to set. The variable should be a global or defined with `var` in the top-level\r\nscope of the module.\r\n\r\n- *{&lowast;} value*: <br/>\r\nThe value to set\r\n\r\n**RewiredModule.&#95;&#95;set&#95;&#95;(***env***)**\r\n\r\n- *{!Object} env*: <br/>\r\nTakes all keys as variable names and sets the values respectively.\r\n\r\n**RewiredModule.&#95;&#95;get&#95;&#95;(***name***): {&lowast;}**\r\n\r\nReturns the private variable.\r\n\r\n<br />\r\n\r\n## Credits\r\n\r\nThis module is inspired by the great [injectr](https://github.com/nathanmacinnes/injectr \"injectr\")-module.","name":"rewire","note":"Don't delete this file! It's used internally to help with page regeneration.","google":""}